---
title: "Functional differences between wild mice microbiome and SPF in ASO mice"
subtitle: "Data: HUMAnN 3.9 unstratified UniRef90 Gene Families"
author: "Daniel Dumitrescu, Giacomo Antonello, Nicola Segata, Levi Waldron, Sarkis Mazmanian"
date: "`r Sys.Date()`"
output:
  rmdformats::readthedown:
    self_contained: true
    toc_depth: 3
    code_folding: hide
    toc_float: true
    number_sections: true
    thumbnails: false
    lightbox: true
    gallery: false
    use_bookdown: true
    highlight: haddock
params:
  basic_outdir: "results"
  assayTested: "gene_family_abundance_rpk_unstratified"
  microbiome_data_type: "GeneFamilies"
  beta_dist: "bray"
  beta_MDS: "MDS"
---

```{r}
knitr::opts_chunk$set(warning = FALSE, message = FALSE)
```

```{r, include=FALSE}
# packages for tabular data manipulation
library(tidyverse)
library(data.table)

# microbiome specific packages
library(maaslin3)
library(limma)
library(mia)
# some packages for data visualization (plots and tables)
library(miaViz)
library(pheatmap)
library(UpSetR)
library(ggpubr)
library(kableExtra)
library(reactable)

# MAC's package to download data
library(parkinsonsMetagenomicData) # devtools::install_github("ASAP-MAC/parkinsonsMetagenomicData")
library(biobakeryUtils) # devtools::install_github("g-antonello/biobakeryUtils")
library(ggh4x) # for complex ggplot2 faceting
# set ggplot2 plot themes 
theme_set(theme_light())
# set seed for reproducibility
set.seed(1234)
```

# Create output directories all in one chunk

```{r}

output_directories.list <- list(
  # alpha diversity directory
  alpha_div_outdir = file.path(params$basic_outdir, params$microbiome_data_type, "01_alpha_diversity"),
  # beta diversity output directory
  beta_div_outdir = file.path(params$basic_outdir, params$microbiome_data_type, "02_beta_diversity")
)

tmp_out <- capture.output(sapply(output_directories.list, dir.create, showWarnings = FALSE, recursive = TRUE))
rm(tmp_out)
```

# Load data for analysis

```{r}
InputHumannData.tse <- read_TSE_from_dir("Data/HUMAnN_genefamilies_unstratified.tse/")
InputHumannData.tse
```

# The vast majority of reads do not map to a pathway

These features will be removed, because they are crushing the remaining pathways

```{r, fig.height = 8, fig.width=12, fig.cap="Stack plot of the top 30 most abundant pathways, with highlight on the distribution of UNMAPPED and UNINTEGRATED reads."}
topN_features <- getTop(InputHumannData.tse, 20, assay.type = params$assayTested)
colors_top2 <- rev(scater:::.get_palette(palette_name = "tableau10medium"))[1:2]
stackplot_top_N <- InputHumannData.tse[topN_features, ] %>% 
  miaViz::plotAbundance(assay.type = params$assayTested) + 
  theme(legend.position = "bottom")+ 
  facet_nested(cols = vars(sex, donor_microbiome_type), scales = "free_x")

stackplot_top_N
```

## UNMAPPED reads vary with Donor microbiome type

```{r}

stats_unintegr_unmapp <- meltSE(InputHumannData.tse, assay.type = params$assayTested, add.col = c("sex", "donor_microbiome_type")) %>% 
  filter(grepl("^UN", FeatureID)) %>% 
  group_by(FeatureID) %>% 
  nest() %>% 
  mutate(
    model = map(data, ~broom::tidy(lm(!!sym(params$assayTested) ~ sex + donor_microbiome_type, data = .x)))
  ) %>% 
  unnest(model)

plot_unintegr_unmapp <- meltSE(InputHumannData.tse[grepl("^UN", rownames(InputHumannData.tse)),], assay.type = params$assayTested, add.col = c("sex", "donor_microbiome_type")) %>% 
  ggplot(aes(x = sex, y = !!sym(params$assayTested), color = donor_microbiome_type)) + 
  geom_boxplot(width = 0.3, show.legend = FALSE) +
  geom_point(position = position_jitterdodge(jitter.width = 0.2, seed = 1234)) +
  facet_wrap(~FeatureID) + 
  labs(
    color = "Donor Microbiome"
  ) + 
  theme_bw() + 
  theme(legend.position = "top") +
  ggpubr::stat_compare_means(method = "t.test", show.legend = FALSE)
```

```{r}
plot_unintegr_unmapp
```

```{r}
stats_unintegr_unmapp %>% 
  select(-data) %>% 
  filter(grepl("donor_microbiome_type", term)) %>% 
  kbl() %>% 
  kable_styling()
```


```
UNMAPPED: Reads did not map to any gene/gene family
UNINTEGRATED: Reads did map into a gene-gene family, BUT but that gene/gene family was not in the pathways database
```

## WildR mice have more Gene families per sample mapped than SPF

```{r}
alpha_indices <- c("dbp_dominance", "gini", "observed_richness", "shannon_diversity")
InputHumannData.tse <- addAlpha(InputHumannData.tse, assay.type = params$assayTested, index = alpha_indices)

tmp <- sapply(alpha_indices, function(div) {
  lm(as.formula(paste(div, "~", "sex + donor_microbiome_type")), data = colData(InputHumannData.tse))
  
}, USE.NAMES = TRUE, simplify = FALSE)

table_results.df <- tmp %>% lapply(broom::tidy) %>% 
  bind_rows(.id = "AlphaIndex") %>% 
  filter(!grepl("Intercept", term))

table_results.df %>%
  kbl() %>% 
  row_spec(which(table_results.df$p.value < 0.05), bold = TRUE, color = "red2") %>% 
  kable_styling()
```

WildR microbiomes show more pathways and minimally more evenly distributed 
abundances of such pathways.

# Compositional differences in relation to the donor microbiome

```{r}
dimRedName <- paste(params$beta_dist, "mds", sep = "_")
# this will work once mia or TreeSummarizedExperiment fixes some things
InputHumannData.tse <- mia::addMDS(
  InputHumannData.tse,
  assay.type = params$assayTested,
  method = params$beta_dist,
  ncomponents = 3, name = dimRedName
  )

variances_explained <- attr(reducedDim(InputHumannData.tse, dimRedName), "eig")
prop_variances_explained <- variances_explained/sum(variances_explained)

mds_data_for_plot.df <- cbind.data.frame(as.data.frame(colData(InputHumannData.tse)), reducedDim(InputHumannData.tse, dimRedName) %>% as.data.frame() %>% set_names(paste("MDS", 1:ncol(.))))

beta_plot_all_features <- mds_data_for_plot.df %>% 
  ggplot(aes(x = `MDS 1`, y = `MDS 2`, color = paste(donor_microbiome_type, sex))) + 
  geom_point(size = 2) + 
  stat_ellipse(show.legend = FALSE) + 
  #scale_color_manual(values = ggsci::pal_jco()(6)) +
  theme(legend.position = "top") +
  labs(color = "Microbiome and Sex",
       x = paste0("MDS 1 [", round(prop_variances_explained[1]*100, 1), "%]"),
       y = paste0("MDS 2 [", round(prop_variances_explained[2]*100, 2), "%]")
  )

```

```{r}
dimRedName <- paste(params$beta_dist, "mds", "no_UN.", sep = "_")
# this will work once mia or TreeSummarizedExperiment fixes some things
InputHumannData.tse <- mia::addMDS(
  InputHumannData.tse[!startsWith(rownames(InputHumannData.tse), "UN"),],
  assay.type = params$assayTested,
  method = params$beta_dist,
  ncomponents = 3, name = dimRedName
  )

variances_explained <- attr(reducedDim(InputHumannData.tse, dimRedName), "eig")
prop_variances_explained <- variances_explained/sum(variances_explained)

mds_data_for_plot.df <- cbind.data.frame(as.data.frame(colData(InputHumannData.tse)), reducedDim(InputHumannData.tse, dimRedName) %>% as.data.frame() %>% set_names(paste("MDS", 1:ncol(.))))

beta_plot_no_UNINT_UNMAP <- mds_data_for_plot.df %>% 
  ggplot(aes(x = `MDS 1`, y = `MDS 2`, color = paste(donor_microbiome_type, sex))) + 
  geom_point(size = 2) + 
  stat_ellipse(show.legend = FALSE) + 
  #scale_color_manual(values = ggsci::pal_jco()(6)) +
  theme(legend.position = "top") +
  labs(color = "Microbiome and Sex",
       x = paste0("MDS 1 [", round(prop_variances_explained[1]*100, 1), "%]"),
       y = paste0("MDS 2 [", round(prop_variances_explained[2]*100, 2), "%]")
  )

```

```{r}
ggsave(plot = beta_plot_all_features, filename = file.path(output_directories.list$beta_div_outdir, "bray_MDS_plot_all_features.png"), dpi = 600, height = 7.5, width = 6)
ggsave(plot = beta_plot_no_UNINT_UNMAP, filename = file.path(output_directories.list$beta_div_outdir, "bray_MDS_plot_no_UNMAP_UNINT.png"), dpi = 600, height = 7.5, width = 6)

ggarrange(beta_plot_all_features + labs(title = "All Features"),
          beta_plot_no_UNINT_UNMAP + labs(title = "All except UNINTEGR. and UNMAPP."),
          common.legend = TRUE)
```

## PERMANOVA statistics

```{r}

InputHumannData.tse <- addPERMANOVA(
  InputHumannData.tse,
  assay.type = params$assayTested,
  method = "bray",
  formula = x ~ sex + donor_microbiome_type,
  name = "permanova",
  permutations = 999,
  test.homogeneity = TRUE
)

permanova_table.df <- PERMANOVA_to_table(InputHumannData.tse)

write_tsv(permanova_table.df, file = file.path(output_directories.list$beta_div_outdir, paste(params$beta_dist, "adonisPermanova", "sex", "donor_microbiome_type.tsv", sep = "_")))
```

```{r}
permanova_table.df %>% 
  kbl() %>% 
  kable_styling()
```

# Differentially abundant taxa in `WildR` mice compared to SPF (with `limma`)

## Sex adjusted

$$
\log_2(Pathway) \sim sex + \text{donor_microbiome_type}
$$

```{r}
# prepare input data

tmp.tse <- InputHumannData.tse
tmp.tse <- tmp.tse[rowSums(assay(tmp.tse)) > 0 , ]
tmp.tse

# define experiment name and output directories
maaslin3_expmt <- "WildR_vs_SPF_adj_sex"
maaslin3_final_outdir <- file.path(params$basic_outdir, params$microbiome_data_type, maaslin3_expmt)
# create definitive output directory
dir.create(maaslin3_final_outdir, showWarnings = FALSE, recursive = TRUE)
```

Results are stored in ``r maaslin3_final_outdir``

```{r}
design.mat <-model.matrix(~ sex + donor_microbiome_type, data = colData(tmp.tse))
# log2 counts per million transformation
assay.voom <- voom(assay(tmp.tse), design = design.mat, plot = TRUE)

limma.fit <- lmFit(assay.voom, design.mat)
limma.fit <- eBayes(limma.fit)

results_table <- topTable(limma.fit, coef = "donor_microbiome_typeWildR", n = Inf, sort.by = "P", adjust.method = "BH") %>% 
  rownames_to_column(params$microbiome_data_type)

# populate with some context like mean abundance or number of cases/controls
N_case_ctrl <- split(x = as.data.frame(t(assay(tmp.tse))), f = colData(tmp.tse)$donor_microbiome_type) %>% 
  lapply(function(x) colSums(x > 0))
mean_log2_abund <- split(x= as.data.frame(t(log2(assay(tmp.tse) + 0.5))), f = colData(tmp.tse)$donor_microbiome_type) %>% 
  lapply(colMeans)

someStats <- tibble(
  !!sym(params$microbiome_data_type) := names(N_case_ctrl$SPF),
  N_WildR = N_case_ctrl$WildR,
  N_SPF = N_case_ctrl$SPF,
  mean_log2_abund_WildR = mean_log2_abund$WildR,
  mean_log2_abund_SPF = mean_log2_abund$SPF
)

results_table_populated <- dplyr::left_join(results_table, someStats, by = params$microbiome_data_type) %>% 
  relocate(B, .after = "t")
```

```{r}
write_tsv(results_table_populated, file = file.path(maaslin3_final_outdir, "all_results_limma.tsv"))
```

## Males

```{r}
# prepare input data

tmp.tse <- InputHumannData.tse[,colData(InputHumannData.tse)$sex == "Male"]
tmp.tse <- tmp.tse[rowSums(assay(tmp.tse)) > 0 , ]
tmp.tse

# define experiment name and output directories
maaslin3_expmt <- "WildR_vs_SPF_Males"
maaslin3_final_outdir <- file.path(params$basic_outdir, params$microbiome_data_type, maaslin3_expmt)
# create definitive output directory
dir.create(maaslin3_final_outdir, showWarnings = FALSE, recursive = TRUE)
```

```{r}
design.mat <-model.matrix(~ donor_microbiome_type, data = colData(tmp.tse))
# log2 counts per million transformation
assay.voom <- voom(assay(tmp.tse), design = design.mat, plot = TRUE)

limma.fit <- lmFit(assay.voom, design.mat)
limma.fit <- eBayes(limma.fit)

results_table <- topTable(limma.fit, coef = "donor_microbiome_typeWildR", n = Inf, sort.by = "P", adjust.method = "BH") %>% 
  rownames_to_column(params$microbiome_data_type)

# populate with some context like mean abundance or number of cases/controls
N_case_ctrl <- split(x = as.data.frame(t(assay(tmp.tse))), f = colData(tmp.tse)$donor_microbiome_type) %>% 
  lapply(function(x) colSums(x > 0))
mean_log2_abund <- split(x= as.data.frame(t(log2(assay(tmp.tse) + 0.5))), f = colData(tmp.tse)$donor_microbiome_type) %>% 
  lapply(colMeans)

someStats <- tibble(
  !!sym(params$microbiome_data_type) := names(N_case_ctrl$SPF),
  N_WildR = N_case_ctrl$WildR,
  N_SPF = N_case_ctrl$SPF,
  mean_log2_abund_WildR = mean_log2_abund$WildR,
  mean_log2_abund_SPF = mean_log2_abund$SPF
)

results_table_populated <- dplyr::left_join(results_table, someStats, by = params$microbiome_data_type) %>% 
  relocate(B, .after = "t")
```

```{r}
write_tsv(results_table_populated, file = file.path(maaslin3_final_outdir, "all_results_limma.tsv"))
```

## Females

```{r}
# prepare input data

tmp.tse <- InputHumannData.tse[,colData(InputHumannData.tse)$sex == "Female"]
tmp.tse <- tmp.tse[rowSums(assay(tmp.tse)) > 0 , ]
tmp.tse

# define experiment name and output directories
maaslin3_expmt <- "WildR_vs_SPF_Females"
maaslin3_final_outdir <- file.path(params$basic_outdir, params$microbiome_data_type, maaslin3_expmt)
# create definitive output directory
dir.create(maaslin3_final_outdir, showWarnings = FALSE, recursive = TRUE)
```

```{r}
design.mat <-model.matrix(~ donor_microbiome_type, data = colData(tmp.tse))
# log2 counts per million transformation
assay.voom <- voom(assay(tmp.tse), design = design.mat, plot = TRUE)

limma.fit <- lmFit(assay.voom, design.mat)
limma.fit <- eBayes(limma.fit)

results_table <- topTable(limma.fit, coef = "donor_microbiome_typeWildR", n = Inf, sort.by = "P", adjust.method = "BH") %>% 
  rownames_to_column(params$microbiome_data_type)

# populate with some context like mean abundance or number of cases/controls
N_case_ctrl <- split(x = as.data.frame(t(assay(tmp.tse))), f = colData(tmp.tse)$donor_microbiome_type) %>% 
  lapply(function(x) colSums(x > 0))
mean_log2_abund <- split(x= as.data.frame(t(log2(assay(tmp.tse) + 0.5))), f = colData(tmp.tse)$donor_microbiome_type) %>% 
  lapply(colMeans)

someStats <- tibble(
  !!sym(params$microbiome_data_type) := names(N_case_ctrl$SPF),
  N_WildR = N_case_ctrl$WildR,
  N_SPF = N_case_ctrl$SPF,
  mean_log2_abund_WildR = mean_log2_abund$WildR,
  mean_log2_abund_SPF = mean_log2_abund$SPF
)

results_table_populated <- dplyr::left_join(results_table, someStats, by = params$microbiome_data_type) %>% 
  relocate(B, .after = "t")
```

```{r}
write_tsv(results_table_populated, file = file.path(maaslin3_final_outdir, "all_results_limma.tsv"))
```

# Differentially abundant/prevalent taxa in `WildR` mice compared to SPF (with `MaAsLin3`)

MaAsLin3 fails with approx. more than 2,000 features to test. While this could
be fixed, it is a burdensome method, and modeling a chunk of 2000 features 
takes 2' 30'', which means ~ 12 h user time on 8 cores. While technically,
MaAsLin3 is widely impractical for Gene Families. Nevertheless, below is 
an example of how to generate results for all (or most) features. 
The code still stops with an error on the incomplete chunk:
`one node produced an error: attempt to set 'rownames' on an object with no dimensions` 

## Sex-adjusted

```{r, eval=FALSE}
# prepare input data

tmp.tse <- InputHumannData.tse
tmp.tse <- tmp.tse[rowSums(assay(tmp.tse)) > 0 , ]
tmp.tse

# define experiment name and output directories
maaslin3_expmt <- "WildR_vs_SPF_adj_sex"
maaslin3_final_outdir <- file.path(params$basic_outdir, params$microbiome_data_type, maaslin3_expmt)
# create definitive output directory
dir.create(maaslin3_final_outdir, showWarnings = FALSE, recursive = TRUE)
```

```{r maaslin3 in parallel attempt with bplapply, eval=FALSE}
#----- Setup parameters---
set.seed(1234)
chunkSize <- 2e3
exact_division <- nrow(tmp.tse) %/% chunkSize
#------------------------
library(BiocParallel)
multicoreParam <- registered()$MulticoreParam
multicoreParam$workers <- multicoreParam$workers - 2

WildR_vs_SPF_adj_Sex.maaslin3 <- bplapply(1:(exact_division + 1), FUN = function(i) {
  # create subsetting indices
  min_indx <- (chunkSize*(i-1) + 1)
  max_indx <- min(i*chunkSize, nrow(tmp.tse))
  # create output directory for the chunk
  maaslin3_final_outdir_chunk <- file.path(maaslin3_final_outdir, paste0("chunk.", i))
  dir.create(maaslin3_final_outdir_chunk)
  
  # subset the original data matrix
  tmp.tse_sub <- tmp.tse[min_indx:max_indx,]
  
  # perform MaAsLin3 and don't bother saving it to memory
  maaslin3(
    input_data = tmp.tse_sub,
    formula = ~ sex + donor_microbiome_type, 
    transform = "LOG",
    output = maaslin3_final_outdir_chunk,
    # do not standardize continuous metadata variables in the model
    standardize = FALSE,
    plot_associations = FALSE,
    save_plots_rds = TRUE,
		verbosity = "ERROR", 
		cores = 1
  )
  return(file.path(maaslin3_final_outdir_chunk, "all_results.tsv"))
}, BPPARAM = multicoreParam
)
```

```{r maaslin3 in parallel attempt with parLapply, eval=FALSE}
#----- Setup parameters---
set.seed(1234)
chunkSize <- 2e3
# Ensure you have the full object name for nrow()
exact_division <- nrow(tmp.tse) %/% chunkSize 
num_cores <- 10 # How many cores to use

#------------------------
# 1. Load the parallel library
library(parallel)

# 2. Create a socket cluster (the safe way)
# This creates 'num_cores' new, clean R sessions.
cl <- makePSOCKcluster(num_cores)

# 3. Export necessary objects to the cluster
# The new R sessions don't know about the objects in your main session,
# so we have to send them the data and variables they will need.
clusterExport(cl, varlist = c("tmp.tse", "chunkSize", "maaslin3_final_outdir"))

# 4. Load required libraries on each worker in the cluster
# Each new session also needs the Maaslin3 library loaded.
clusterEvalQ(cl, {
  library(maaslin3)
})

# 5. Run the analysis using parLapply
WildR_vs_SPF_adj_Sex.maaslin3 <- parLapply(cl, 1:(exact_division + 1), fun = function(i) {
  # create subsetting indices
  min_indx <- (chunkSize * (i - 1) + 1)
  max_indx <- min(i * chunkSize, nrow(tmp.tse))
  
  # create output directory for the chunk
  maaslin3_final_outdir_chunk <- file.path(maaslin3_final_outdir, paste0("chunk.", i))
  # Use showWarnings = FALSE and recursive = TRUE for cleaner execution
  dir.create(maaslin3_final_outdir_chunk, showWarnings = FALSE, recursive = TRUE)
  
  # subset the original data matrix
  tmp.tse_sub <- tmp.tse[min_indx:max_indx, ]
  
  # perform MaAsLin3
  maaslin3(
    input_data = tmp.tse_sub,
    formula = ~ sex + donor_microbiome_type, 
    transform = "LOG",
    output = maaslin3_final_outdir_chunk,
    standardize = FALSE,
    plot_associations = FALSE,
    save_plots_rds = TRUE,
    verbosity = "ERROR", 
    cores = 1
  )
  
  # Return the path to the results file for this chunk
  return(file.path(maaslin3_final_outdir_chunk, "all_results.tsv"))
})

# 6. IMPORTANT: Always stop the cluster when you're done
# This closes the extra R sessions and frees up memory.
stopCluster(cl)
```

then you need to read-in all results and bind them. it would be easier to `cat` 
from bash.

```{r, eval=FALSE}
full_path <- file.path(getwd(), maaslin3_final_outdir)
common_header <- read_tsv(file.path(maaslin3_final_outdir, "chunk.1", "all_results.tsv"), n_max = 1) %>% 
  colnames()
readr::read_tsv(file.path(full_path, "chunk.2", "all_results.tsv"))

results_readIn.dt <- data.table::fread(cmd = sprintf("find %s -type f -name 'all_results.tsv' -exec cat {} +", full_path), col.names = common_header)
# remove extra headers
results_readIn.dt <- results_readIn.dt[feature != "feature",]

# re-write as cumulative results
write_tsv(results_readIn.dt, file = file.path(maaslin3_final_outdir, "all_results_joinedChunks.tsv"))

# show it
results_readIn.dt
```

# Session Info

```{r}
sessionInfo()
```
